# Flow Control

The third main task of the data link layer is that it needs to manage and control how many frames are being sent from one machine to another. It can definitely be possible that a higher-end, more powerful machine wants to send a larger number of frames but to a lower-end, less powerful machine. In this process, the receiver machine may not be able to handle the frames that are being sent and due to this, some frames will be dropped.

It is up to the data link protocol to make sure that this doesn't happen.  One such example of a situation in which this sort of thing might happen is when a mobile phone requests a web server for a web page.

1. Feedback-based flow control
2. Rate-based flow control

# Requirements For The Data Link Layer

1. It must deliver packets back to the network layer in the same order that they were sent in.
2. It must deliver the frames in the same order that they were sent in. 

# Stop-and-Wait Protocol

## For An Error Free Channel

Lets assume (for simplicity sake), that the channel is completely error free. In this case, our main task would to be implement flow control, rather than detect errors in frames.

In this protocol, the sender sends a frame, and simply waits for a dummy frame to be sent back. This is the simplest type of protocol and implements a very basic form of a flow control. 

## For a Noisy Channel

In a noisy channel, the assumption is that frames can either be damaged or lost entirely. This is the prime assumption that we need to fix. Hence, this is a better example of what the data link layer should be doing.

It is important to note however that the Network Layer must have no idea that the channel is noisy. It should simply be able to send and receive its packets from one machine to another machine without any errors. This is the assumption that the network layer takes while working.

### How Many Bits Are Required For A Sequence Number?

Lets take the case where a frame is received without errors at the machine B. It then proceeds to send a control frame back to machine A. Now assume that due to the nature of the noisy channel, this acknowledgement frame is dropped. Consequently, machine A will resend frame 1. When this is received by machine B without any errors, it is again passed to the Network Layer. This is a huge error, as the network layer would be receiving duplicate packets even though the network layer on machine A did not send any duplicate packets.

In order to fix this issue, we can make use of a sequence number for each frame. In this way, if a frame has already been received with a particular sequence number, then it can simply be dropped. 

Since we only need to differentiate between the current packet and its most immediate predecessor, we only need 1 bit for a sequence number. This is more than enough in order to signify whether the current frame is the right one or not.

ARQ stands for Automatic Repeat reQuest while PAR stands for Positive Acknowledgement with Retransmission.

## Piggybacking

In most practical cases, we need to have communication or data transfer in both directions. It would be simple to use 4 separate links instead but this would be highly efficient and the data transfer capabilities of the reverse channel links are going to be mostly wasted. Instead, what we can do is make use of the same channel in the full-duplex mode. 

So now from a machine A to a machine B, there will be data frames as well as acknowledgement frames being sent together. The receiving machine can decipher what type of frame it is from the 'type' field in the frame header. It can then get to know whether its a frame containing some data or whether it is simply just a control frame.

Another nice way of looking at things and making sure they are a bit more efficient is to send an acknowledgement along with a data frame containing information. This can be done by setting the acknowledgement field in the frame header. As such, the acknowledgement gets a free ride on the data frame. This is known as piggybacking.

### Advantages

1. Better use of the channel bandwidth as the acknowledgement field in the frame header only consists of a few bits.

### Disadvantages

1. How long should the data link layer wait for the acknowledgement, considering that the machine A would wait until a new packet would have to be sent from the Network Layer.

The best way to look at it would be that you piggyback if in case a new packet is being generated by the network layer, otherwise a normal acknowledgement frame would have to be sent.

# Sliding Window Protocols

The essence of all sliding window protocols is that at any instant of time, both the sender and the receiver are are maintaining a window of frames that have to be sent or received. The lower and upper limits of this frame on both sides need not be the same and that is very important.

The sender's window has frames that have been sent but haven't been acknowledged yet. Whenever a new packet comes from the network layer, it is given the highest sequence number, and whenever an acknowledgement comes in, the lower end of the sliding window is incremented by 1. In this way, on the sender's side, we constantly maintain the list of unacknowledged frames.

The receiver's window has frames that it may accept. Any other frames are discarded. In the case that it receives a frame that is present in its sliding window, then 